package framework.bean;

import static org.assertj.core.internal.DeepDifference.determineDifferences;


import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import framework.bean.annotations.Autogenerated;
import framework.bean.annotations.SortBy;
import framework.utilities.BeanUtils;
import framework.utilities.Encoding;
import framework.utilities.ReflectionUtil;
import framework.utilities.graphqlmapper.GraphQlConvert;
import framework.utilities.objectmapper.DtoConvert;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.assertj.core.internal.DeepDifference;


public abstract class AbstractDto implements Comparable<Object> {

    protected static final Logger LOGGER = LogManager.getLogger();

    public AbstractDto() {
        //default
    }

    @JsonIgnore
    public Map<Object, Object> unknownFields = new HashMap<>();

    @JsonAnyGetter
    public Map<Object, Object> any() {
        return unknownFields;
    }

    @JsonAnySetter
    public void set(Object name, Object value) {
        unknownFields.put(name, value);
    }

    public void setFieldByJsonPropertyName(String name, Object value) {
        ReflectionUtil.setFieldByJsonPropertyName(this, name, value);
    }

    public Object getFieldValueByJsonPropertyName(String name) {
        return ReflectionUtil.getFieldByJsonPropertyName(this, name);
    }

    public Object getByBeanPath(String name) {
        Map<String, String> nonNullFields = BeanUtils.recursiveDescribe(this);
        return nonNullFields.get(name);
    }

    public Object getFieldValueByJsonPropertyNameIgnoreCase(String name) {
        return ReflectionUtil.getFieldByJsonPropertyNameIgnoreCase(this, name);
    }

    public boolean hasUnknownProperties() {
        return !unknownFields.isEmpty();
    }

    /**
     * Retrieve field names annotated with Autogenerated annotation.
     * @return String[]
     */
    @JsonIgnore
    public String[] retriveAutogeneratedAnnotations() {
        try {
            return this.getClass().getAnnotation(Autogenerated.class).value();
        } catch (Exception e) {
            return new String[]{""};
        }
    }

    @Override
    public String toString() {
        return toJsonString();
    }

    public String toStringRepresentation() {
        return ReflectionToStringBuilder.toString(this,
            ToStringStyle.MULTI_LINE_STYLE, true, false);
    }

    public String toXFormUrlEncodedString() {
        return DtoConvert.dtoToXFormUrlEncoded(this);
    }

    public static AbstractDto fromXFormUrlEncodedString(String content, AbstractDto klass) {
        return DtoConvert.xformUrlEncodedToDto(klass.getClass(), content);
    }

    public void fromXFormUrlEncodedString(String content) {
        DtoConvert.xformUrlEncodedToDto(this, content);
    }

    public String toJsonString() {
        return DtoConvert.dtoToJsonString(this);
    }

    /**
     * Convert this object into GraphQL query string.
     * Class should be annotated with GraphQlQuery annotation in order to form graph ql string
     * @return String
     */
    public String toGraphQlQueryString() {
        return GraphQlConvert.toQueryString(this.getClass());
    }

    public String toPrettyJsonString() {
        return DtoConvert.dtoToPrettyJsonString(this);
    }

    public String toYamlString() {
        return DtoConvert.dtoToYaml(this);
    }

    @JsonIgnore
    public String toBase64() {
        String requestBody = this.toJsonString();
        return Encoding.encodeStringToBase64(requestBody);
    }

    public static <T> T fromMap(Map<String, Object> obj, Class<T> clazz) {
        return DtoConvert
            .mapToDto(clazz, obj, false);
    }

    public static <T extends AbstractDto> T fromJsonString(String val, Class<T> klass) {
        return DtoConvert.stringToDto(klass, val, false);
    }

    public static <T extends AbstractDto> T fromYamlString(String val, Class<T> klass) {
        return DtoConvert.yamlFileToDto(klass, val, false);
    }

    /**
     * Recursively traverse dto and sort any List on its way.
     * @param <T> any type extending AbstractDto
     * @return this
     */
    @JsonIgnore
    public <T extends AbstractDto> T sorted() {
        try {
            this.sortDto(this);
            return (T) this;
        } catch (IllegalAccessException e) {
            LOGGER.error(e);
        }
        return (T) this;
    }

    @JsonIgnore
    @SuppressWarnings("unchecked")
    private void sortDto(Object dto) throws IllegalAccessException {
        if (dto != null) {
            if (dto instanceof List) {
                Collections.sort((List) dto);
                for (Object listItem : (List) dto) {
                    this.sortDto(listItem);
                }
            } else if (dto instanceof AbstractDto) {
                for (Field field : dto.getClass().getFields()) {
                    this.sortDto(field.get(dto));
                }
            }
        }
    }

    /**
     * Get ordered field names from JsonPropertyOrder.
     * @param dto Class to be used
     * @return String[]
     */
    @JsonIgnore
    @SuppressWarnings("unchecked")
    public static String[] getOrderedFieldNames(Class<?> dto) {
        try {
            return dto.getAnnotation(JsonPropertyOrder.class).value();
        } catch (Exception e) {
            return new String[]{""};
        }
    }

    /**
     * Retrieve array of fields annotated by JsonProperty annotation.
     * @param dto Class to be used
     * @return String[]
     */
    @JsonIgnore
    public static String[] getJsonPropertiesForFieldNames(Class<?> dto) {
        List<String> jsonProperties = new ArrayList<>();
        try {
            for (Field field : dto.getDeclaredFields()) {
                jsonProperties.add(field.getAnnotation(JsonProperty.class).value());
            }
            return jsonProperties.toArray(new String[jsonProperties.size()]);
        } catch (Exception e) {
            return new String[]{""};
        }
    }

    /**
     * Retrieve ordered array of fields annotated by JsonProperty annotation.
     * @param dto Class to be used
     * @return String[]
     */
    @JsonIgnore
    @SuppressWarnings("unchecked")
    public static String[] getOrderedJsonProperties(Class<?> dto) {
        List<String> jsonPropertyOrder = new ArrayList<>();
        try {
            for (String fieldName : getOrderedFieldNames(dto)) {
                String jsonPropertyName = dto.getDeclaredField(fieldName).getAnnotation(JsonProperty.class).value();
                jsonPropertyOrder.add(jsonPropertyOrder.size(), jsonPropertyName);
            }
            return jsonPropertyOrder.toArray(new String[jsonPropertyOrder.size()]);
        } catch (Exception e) {
            return new String[]{""};
        }
    }

    /**
     * Merge other object with current object; null values are skipped.
     *
     * @param other T
     */
    public <T extends AbstractDto> T merge(T other) {
        Map<String, String> otherObject = BeanUtils.recursiveDescribe(other);
        otherObject.forEach((key, value) ->
            BeanUtils.setProperty(this, key, BeanUtils.getProperty(other, key)));
        return (T) this;
    }

    /**
     * Merge other object with current object; null values are skipped.
     *
     * @param other T
     */
    public <T extends AbstractDto> T mergeNulls(T other) {
        Map<String, String> otherObject = BeanUtils.recursiveDescribe(other);
        otherObject.forEach((key, value) -> {
            if (BeanUtils.getProperty(this, key) == null) {
                BeanUtils.setProperty(this, key, BeanUtils.getProperty(other, key));
            }
        });

        return (T) this;
    }

    /**
     * Compare objects using custom comparator for defined fields.
     * Fields that are not passed, will be compared using equals
     * @param other Other object of same type
     * @param comparator Comparator
     * @param propertiesOrFields var args of fields to apply comparator.
     * @param <T> any type
     * @return boolean if objects are equal
     */
    public <T extends AbstractDto> boolean equalsUsingComparatorForFields(T other, Comparator<?> comparator,
        String... propertiesOrFields) {
        Map<String, Comparator<?>> comparatorByPropertyOrField = new HashMap<>();

        for (String propertyOrField : propertiesOrFields) {
            comparatorByPropertyOrField.put(propertyOrField, comparator);
        }
        List<DeepDifference.Difference> differences = determineDifferences(this, other, comparatorByPropertyOrField,
            null);
        return differences.isEmpty();
    }

    /**
     * Compare object with other object ignore or not ignore null fields Comparing complex object.
     */
    public <T extends AbstractDto> boolean equalsIgnoringNullFields(T other) {
        Map<String, String> nonNullFields = BeanUtils.recursiveDescribe(other);
        Map<String, String> thisFields = BeanUtils.recursiveDescribe(this);
        for (Map.Entry<String, String> entry : nonNullFields.entrySet()) {
            if (!thisFields.containsKey(entry.getKey())) {
                return false;
            }
            Object otherValue = BeanUtils.getProperty(other, entry.getKey());
            Object actualValue = BeanUtils.getProperty(this, entry.getKey());
            if (!otherValue.equals(actualValue)) {
                return false;
            }
        }
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof AbstractDto)) {
            return false;
        }

        return new EqualsBuilder()
            .isEquals();
    }

    @Override
    public int hashCode() {
        return new HashCodeBuilder(17, 37)
            .append(unknownFields)
            .toHashCode();
    }

    @JsonIgnore
    @Override
    public int compareTo(Object obj) {
        // get annotated field and use it to sort collection
        String fieldName = this.getClass().getAnnotation(SortBy.class).value();
        boolean found = true;
        Object valueThis = null;
        Object valueOther = null;

        if (obj instanceof AbstractDto) {
            try {
                Field filedObj = this.getClass().getField(fieldName);
                valueThis = filedObj.get(this);
                valueOther = filedObj.get(obj);
            } catch (Exception e) {
                found = false;
            }
            if (found && valueThis instanceof Comparable && valueOther instanceof Comparable) {
                return ((Comparable) valueThis).compareTo(valueOther);
            }
        }
        return 0;
    }

    public Map<String, Object> toMap() {
        return DtoConvert.dtoToMap(this);
    }

    /**
     * Retrieve declared fields from this and child object.
     * @return Field list
     */
    @JsonIgnore
    public List<Field> retrieveDeclaredFields() {
        List<Field> fields = new ArrayList<>();
        Collections.addAll(fields, this.getClass().getDeclaredFields());
        Collections.addAll(fields, this.getClass().getSuperclass().getDeclaredFields());
        return fields;
    }
}

